# Middle с ответами

## Общие вопросы

1. Расскажите о пирамиде тестирования.
Ответ: Пирамида тестирования показывает, что большую часть автоматизации составляют unit-тесты, над ними располагаются интеграционные, а на вершине — e2e‑тесты.

2. Какие типы автоматизированных тестов вам случалось писать? Какие библиотеки при этом использовали? Какие инструменты предпочитаете и почему?
Ответ: Чаще всего пишут unit‑тесты с Jest или Mocha, интеграционные с Jest или Cypress, e2e с Cypress или Selenium. Выбор зависит от проекта и удобства инструментов.

3. Что такое unit-тесты? Какое место в пирамиде тестирования занимают unit-тесты?
Ответ: Unit‑тесты проверяют отдельные функции или модули без зависимостей. Они находятся в основании пирамиды и должны быть самыми многочисленными.

4. Что такое code coverage? Обязательно ли 100% покрытие кода тестами?
Ответ: Code coverage отображает долю исполняемого кода, покрытого тестами. Достигать 100% не всегда нужно, важнее покрыть критические участки.

5. Как запретить браузеру отдавать кэш на HTTP-запрос?
Ответ: Можно отправлять заголовок `Cache-Control: no-cache` или использовать случайный параметр в URL, чтобы обойти кэширование.

6. Что такое XSS (Cross-Site Scripting)?
Ответ: XSS — это атака, при которой злоумышленник внедряет вредоносный скрипт на страницу, что позволяет красть данные или выполнять действия от имени пользователя.

7. Расскажите о паттернах Observer, Pub/Sub. Чем они отличаются? Приведите примеры реализации этих паттернов в известных фреймворках (библиотеках, браузерных API).
Ответ: Observer предполагает наличие объекта‑наблюдателя и субъекта, который уведомляет его об изменениях. Pub/Sub разделяет издателя и подписчика через посредника. В браузере примером служит `EventTarget`.

8. С какой целью может быть использован event listener события fetch self.addEventListener('fetch', event => {})?
Ответ: Такой слушатель применяется в сервис‑воркере для перехвата сетевых запросов и возможности кешировать ответы или подменять их.

9. Что такое Event loop и как он работает? Расскажите о микрозадачах и макрозадачах.
Ответ: Event loop организует очередность выполнения кода в браузере. Микрозадачи (promise callbacks) выполняются после текущего стека, а макрозадачи (setTimeout, I/O) — после микрозадач.

## JS Core

10. Какие типы данных бывают в JavaScript? Каким будет результат выполнения кода?
Ответ: Есть примитивы (number, string, boolean, null, undefined, symbol, bigint) и объекты. В приведенном примере в консоль выводится `Hello`, так как `secondObj` ссылается на первоначальный объект.

11. Что такое temporal dead zone?
Ответ: TDZ — область, где переменная `let` или `const` уже объявлена, но еще не инициализирована. Обращение к ней вызывает ошибку ReferenceError.

12. Как работает boxing/unboxing в JavaScript?
Ответ: При обращении к методу примитива создается временный объект‑обертка (boxing), после выполнения методa он удаляется (unboxing).

13. В чем разница между оператором in и методом hasOwnProperty?
Ответ: `in` проверяет наличие свойства в объекте с учетом цепочки прототипов, а `hasOwnProperty` — только собственные свойства объекта.

14. Опишите, с помощью чего в JS реализуются такие ООП-парадигмы, как инкапсуляция, полиморфизм, абстракция?
Ответ: Инкапсуляция достигается через области видимости и модули, полиморфизм — благодаря переопределению методов в прототипах, абстракция — через создание интерфейсов функций и классов.

15. Что такое прототип? Как работает прототипное наследование в JS? Объясните работу кода.
Ответ: Прототип — это объект, от которого другие объекты наследуют свойства. В примере `obj` останется с `protected: true`, потому что ссылка на прототип устанавливается при создании.

16. В чем разница между композицией и наследованием?
Ответ: Наследование создаёт иерархию классов, а композиция объединяет объекты, используя их функциональность без жесткой связи по предкам.

17. Почему не стоит использовать конструкторы типа new String?
Ответ: Они создают объект вместо примитива, что усложняет сравнение и приводит к неожиданному поведению. Лучше использовать литералы.

18. Расскажите о базовом устройстве и механизме работы Event loop.
Ответ: Event loop последовательно извлекает задачи из очередей: сначала микрозадачи, затем макрозадачи, обеспечивая асинхронность исполнения в одном потоке.

19. Что такое записи (records) и кортежи (tuples)? Чем они отличаются от обычных объектов?
Ответ: Records и tuples — неизменяемые структурированные данные из предложения TC39. Они не имеют прототипов и сравниваются по значению.

20. Каковы различия в поведении ES5 функции-конструктора и ES2015 класса?
Ответ: Класс синтаксически удобнее, но работает как функция‑конструктор. Классы не поднимаются (no hoisting) и всегда вызываются с `new`.

21. Как реализовать паттерн «Модуль»?
Ответ: Используют самовызывающуюся функцию, которая возвращает публичный API, а внутренние данные остаются недоступными снаружи.

22. Почему typeof null возвращает object?
Ответ: Это историческая ошибка реализации JS: нулевая ссылка имела тип object в первоначальном коде движка.

23. Что такое приведение (преобразование) типов в JS?
Ответ: Изменение типа значения к требуемому. Бывает явное через функции-конструкторы и неявное при сравнении или арифметике.

24. Что такое явное и неявное приведение типов данных в JS? Как происходит преобразование типов в примерах?
Ответ: Явное — когда разработчик сам вызывает преобразование, неявное — когда движок делает это автоматически. В примерах: `{}`+[]+{}+[1] даст "[object Object][object Object]1"; `!!"false" == !!"true"` вернет true; `['x'] == 'x'` также true, т.к. массив приводится к строке.

25. Что такое Garbage Collector?
Ответ: Механизм освобождения памяти в движке JavaScript, удаляющий объекты, на которые нет ссылок.

26. Опишите основные принципы работы «сборщика мусора» в JS-движках (engines).
Ответ: Наиболее распространен алгоритм mark-and-sweep: объекты помечаются как достижимые, неиспользуемые удаляются. Также есть сборка поколений и инкрементальная очистка.

27. Опишите назначение и принципы работы с коллекциями WeakMap и WeakSet. Чем они отличаются от коллекций Map и Set соответственно?
Ответ: WeakMap и WeakSet хранят только слабые ссылки на объекты-ключи. Если на объект больше нет ссылок, он удаляется сборщиком, что исключает утечки памяти. Map и Set держат сильные ссылки.

28. Чем Observable отличается от Promise?
Ответ: Promise представляет единственный результат, а Observable — поток значений во времени и поддерживает отписку.

29. Что такое Promise? Назовите порядок выполнения then и catch в цепочке.
Ответ: Promise — объект для работы с асинхронными операциями. then вызываются последовательно в порядке добавления, catch перехватывает первую ошибку и продолжает цепочку.

30. Расскажите о последовательном и параллельном выполнении асинхронных функций. В чем разница между Promise.all и Promise.allSettled?
Ответ: Функции можно запускать одну за другой, ожидая завершения, или параллельно. Promise.all ждёт успешного выполнения всех промисов и отклоняется при первой ошибке, а Promise.allSettled возвращает массив результатов независимо от ошибок.

31. Что такое дескрипторы свойств объектов? Расскажите об их практическом применении.
Ответ: Дескриптор описывает атрибуты свойства: значение, доступность для записи, перечисление и конфигурацию. Позволяет создавать неизменяемые свойства или геттеры/сеттеры.

32. Назовите несколько способов создания постоянного объекта в JavaScript.
Ответ: Можно заморозить объект `Object.freeze`, использовать `const` для ссылки или создавать объект через замыкание без внешнего доступа.

33. Как создать изменяемое свойство у объекта?
Ответ: Определить свойство через `Object.defineProperty` с `writable: true` и соответствующими геттерами/сеттерами.

34. Зачем нужен конструктор Proxy? Приведите пример использования.
Ответ: Proxy позволяет перехватывать операции с объектом: чтение свойств, вызовы функций и т.д. Например, можно реализовать валидацию или логирование доступа к свойствам.

35. Что такое ArrayBuffer? В чем разница между Uint32Array и Float32Array? Каким будет результат выполнения кода?
Ответ: ArrayBuffer — общее хранилище для бинарных данных. Uint32Array хранит беззнаковые 32-битные целые, Float32Array — числа с плавающей точкой. `Array.isArray(uint32Array)` вернет false.

36. Каким будет результат сравнения?
Ответ: `encodeURI(url) == encodeURIComponent(url)` вернет false, потому что encodeURIComponent экранирует больше символов.

37. Расскажите о генераторах и итераторах.
Ответ: Генераторы — функции, выполнение которых можно приостанавливать оператором `yield`. Они возвращают итераторы, позволяющие поочередно получать значения.

38. Объясните, что делает следующий код.
Ответ: Функция‑генератор `fn` при каждом вызове `next()` выводит очередное число от 0 до 4 через console.log.

39. Расскажите о типе данных Symbol и его практическом применении. Как перевести число из 10-разрядной системы в 16(2,8)-разрядную систему счисления?
Ответ: Symbol создаёт уникальное значение, которое можно использовать как ключ объекта. Перевод числа осуществляется методом `number.toString(radix)`.

## Функции

40. Объясните, что означает currying. Приведите пример использования на практике.
Ответ: Currying — преобразование функции с несколькими аргументами в цепочку функций по одному аргументу. Это позволяет частично применять аргументы.

41. Приведите пример функции с мемоизацией. Когда следует применять эту технику?
Ответ: Мемоизация — кеширование результатов функции. Её используют при тяжелых вычислениях для ускорения повторных вызовов.

42. Что такое чейнинг функций? Напишите пример с использованием этого подхода.
Ответ: Чейнинг — когда методы возвращают объект для последовательных вызовов. Например, в библиотеках типа jQuery.

43. В чем разница между function и arrow function? Каким будет результат выполнения кода?
Ответ: Arrow-функции не имеют собственного `this` и не могут быть конструкторами. В примере в консоль попадёт результат работы функций compose и unfold.

## Фронтенд

44. В чем принципиальная разница между событиями mouseleave и mouseout?
Ответ: mouseleave не всплывает и срабатывает один раз при уходе курсора с элемента. mouseout всплывает и может вызываться при каждом выходе вглубь дочерних элементов.

45. В каком порядке обрабатываются пользовательские события в DOM (click, mouseover и т.д.)? FIFO или LIFO?
Ответ: События помещаются в очередь и обрабатываются в порядке поступления (FIFO).

46. Что такое Event bubbling и Event capturing?
Ответ: Всплытие (bubbling) — событие поднимается от целевого элемента вверх. Захват (capturing) — обратный процесс, когда обработчики запускаются от корня к цели.

47. Сравните методы объекта event stopPropagation и stopImmediateProparation.
Ответ: `stopPropagation` прекращает дальнейшее всплытие, но другие обработчики на текущем элементе выполнятся. `stopImmediatePropagation` останавливает и всплытие, и выполнение оставшихся обработчиков на этом элементе.

48. Какие есть подходы к оптимизации производительности веб-страницы?
Ответ: Использование кеширования, минимизация и компрессия ресурсов, отложенная загрузка, оптимизация рендеринга и уменьшение количества DOM-операций.

49. Как реализован механизм same-origin policy в браузере? На какие браузерные API он распространяется?
Ответ: Браузер блокирует доступ к ресурсам с другого происхождения (схема, хост, порт). Политика касается DOM, cookies, localStorage, XMLHttpRequest и др.

50. Назовите способы хранения данных в браузере. Сравните их.
Ответ: Это cookies, localStorage, sessionStorage и IndexedDB. Cookies отправляются серверу, localStorage и sessionStorage работают только на клиенте, IndexedDB хранит сложные структуры.

51. Web worker-ы. Опишите особенности передачи данных между worker-ми и основным потоком, между разделенными worker-ми.
Ответ: Общение происходит через постинг сообщений. Данные копируются или передаются как Transferable объекты для лучшей производительности.

51. Что такое Transferable-объекты?
Ответ: Это объекты, право владения которыми можно передать между потоками без копирования, например ArrayBuffer.

52. Расскажите о способах оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга контента на странице.
Ответ: Использование Web Worker, разделение задач на микротаймслайсы, debounce/throttle, кеширование вычислений.

53. Почему ResizeObserver вызывает события изменения размера до воспроизведения элемента, а не после?
Ответ: Чтобы избежать дополнительных перерисовок и рекурсии, события ResizeObserver выполняются перед тем, как браузер завершит цикл рендеринга.

54. Расскажите, как вы понимаете Web Accessibility.
Ответ: Это набор практик по созданию доступных для людей с ограничениями возможностей веб-сайтов, включая семантическую разметку и поддержку навигации с клавиатуры.

55. Опишите алгоритм создания функционала, обеспечивающего чтение содержимого .txt-файла при перетаскивании его из файловой системы в окно браузера.
Ответ: Нужно обработать событие `drop`, получить файл из `DataTransfer`, прочитать его с помощью `FileReader` и вывести содержимое.

56. Что такое Virtual DOM?
Ответ: Это легковесная копия DOM, используемая фреймворками (React, Vue) для вычисления изменений и эффективного обновления реального DOM.

## Верстка

57. Объясните разницу между единицами измерения px, em, rem.
Ответ: px — абсолютные пиксели. em зависит от размера шрифта родителя, rem — от корневого шрифта документа.

58. Для чего нужны CSS-переменные? Приведите несколько примеров использования.
Ответ: CSS-переменные хранят значения свойств, позволяя переиспользовать их в стилях и легко менять тему интерфейса.

59. Что произойдет при добавлении следующего селектора?
Ответ: Все элементы будут использовать модель коробки border-box, при которой размеры включают рамку и паддинги.

60. Как адаптировать страницу для печати?
Ответ: Используют медиавыражение `@media print` с отдельными стилями, скрывают ненужные элементы и задают размеры страницы.

61. Опишите особенности кастомизации стилей стандартных элементов форм.
Ответ: Браузеры ограничивают стилизацию системных элементов, поэтому часто прячут оригинальный элемент и создают свою оболочку с JS-обработкой.

62. Что такое progressive рендеринг? Какие подходы в нем используются?
Ответ: Это метод ускорения отображения контента: сначала отрисовываются критические части, затем остальное. Используются lazy-loading, подгрузка шрифтов и разбиение кода.

63. Назовите несколько способов реализации lazy-loading медиаресурсов на странице.
Ответ: Использование атрибута `loading="lazy"`, Intersection Observer или динамическая подстановка элементов по мере прокрутки.

64. Назовите популярные шаблонизаторы для фронтенд-разработки. Опишите особенности их использования.
Ответ: Handlebars, Pug, Mustache — позволяют отделить разметку от логики и генерировать HTML на основе данных.

65. Назовите популярные CSS-методологии и их различия.
Ответ: БЭМ, OOCSS и SMACSS задают правила именования и структуры стилей для упрощения поддержки больших проектов.

66. Как работает CSS Grid?
Ответ: CSS Grid задаёт двумерную сетку, в которой элементы можно располагать по строкам и столбцам, управляя размером и расположением.

67. Какие форматы изображений поддерживают анимацию?
Ответ: GIF, APNG и SVG.

68. Как отследить прогресс / окончание CSS @keyframes анимаций или плавных переходов, реализованных с помощью transition, в JS?
Ответ: Через события `animationiteration`, `animationend` и `transitionend`.

69. Какие CSS-свойства могут быть обработаны непосредственно через GPU? Что такое композитные слои и почему большое их количество может привести к аварийному завершению работы браузера на мобильных устройствах?
Ответ: GPU ускоряет трансформации и opacity. При создании множества композитных слоёв растёт потребление памяти и может происходить сбой.

70. Как переиспользовать инлайновые SVG-элементы на странице?
Ответ: Можно определять `symbol` внутри `<svg>` и ссылаться через `<use>` или вынести SVG в отдельный файл и подключать.

71. Опишите способы оптимизации SVG-файлов.
Ответ: Удаление лишних атрибутов и комментариев, объединение путей, использование инструмента svgo.

72. Как реализовать иконочный шрифт из определенного набора SVG-файлов?
Ответ: Нужно конвертировать SVG в набор глифов через инструменты типа IcoMoon, затем подключить получившийся шрифт через @font-face.

73. Что такое ложное жирное или ложное курсивное (Faux) начертания шрифтов?
Ответ: Когда браузер имитирует жирный или курсивный стиль, если выбранный шрифт не имеет нужного начертания.

74. Что такое #shadow-root в инспекторе HTML-страницы?
Ответ: Это отображение теневого DOM элемента веб-компонента, содержимое которого изолировано от основного дерева.

75. Зачем нужны Custom Elements?
Ответ: Они позволяют создавать собственные HTML-теги с инкапсулированной логикой и стилями.

76. Почему удаление лишних символов пробелов (и символов переноса) в HTML не отражается на конечной производительности загрузки страницы?
Ответ: Современные протоколы и сжатие (gzip, brotli) минимизируют вклад пробелов в размер, поэтому влияние незаметно.

77. Что такое контекст отображения canvas? Какие существуют типы контекста для рендеринга двумерной и трехмерной графики?
Ответ: Контекст canvas предоставляет методы рисования. Существуют 2D контекст и WebGL для трёхмерной графики.

